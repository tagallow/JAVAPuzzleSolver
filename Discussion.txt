Tom Galloway
IT340
Program 1 Discussion
After getting all my data together, it was very interesting to see how the different algorithms compared. I was surprised at how different of results I got between with depth first search and breadth first search. DFS returns horribly roundabout solutions to even the simplest of problems, due to the order in which the successor states are produced. However, when the problems become more complicated BFS starts checking more and more unnecessary nodes since the solution is deeper in the tree, and the tree keeps getting wider. Eventually with the hardest problems I could find, BFS is unable to finish solve the problem due to lack of memory. DFS is able to finish, although still giving a ridiculously roundabout solution. I also found it interesting that DFSâ€™s path costs were usually relatively close to the total number of nodes checked. 
I was amazed at how much faster A* search was. I found it interesting that even though A* search with the number out of place heuristic checks many more nodes than DFS in harder problems, it still returns the shortest path in less time. I think the reason for this is the same as the one I mentioned before with BFS, except now the algorithm is just more efficient. 
The improvements from the out of place heuristic to the Manhattan distance heuristic are drastic. The Manhattan distance heuristic allows the A* search to check less nodes, and still find the shortest path every time. This is because the Manhattan distance heuristic provides much more useful information than just how many tiles are out of place. The Manhattan distance also accounts for how far out of place each tile is. 
